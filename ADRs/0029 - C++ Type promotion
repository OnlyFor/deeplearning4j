# Implement Consistent Type Promotion for Arithmetic Operations

## Status

**Proposed**

Proposed by: Adam Gibson Sep 13,2024

## Context

Our C++ codebase currently uses a mix of type-specific operations and generic templates for arithmetic operations. This inconsistency leads to subtle bugs, performance issues, and difficulties in maintaining and extending the code. There is a need to standardize our approach to type promotion, particularly in mathematical operations involving different numeric types.

## Proposal

We propose to implement a consistent type promotion system for arithmetic operations across the codebase. The key features of this proposal include:

1. Defining a type trait system for determining the highest precision type among a set of types.
2. Creating a macro or template system for automatic type promotion in arithmetic operations.
3. Updating existing arithmetic functions to use the new type promotion system.
4. Maintaining specializations for platform-specific optimizations where necessary.
5. Updating documentation and coding standards to reflect this change.

Example of the proposed change:

\```cpp
// Before
template <typename T, typename Z>
SD_HOST_DEVICE SD_INLINE Z sd_add(T val1, T val2) {
    return static_cast<Z>(val1 + val2);
}

// After
#define SD_PROMOTE_FUNC(FUNC_NAME, BODY)                           \
template<typename... Args>                                         \
SD_HOST_DEVICE SD_INLINE                                           \
auto FUNC_NAME(Args... args) {                                     \
    using promoted_type = promoted_type_t<Args...>;                \
    return (BODY);                                                 \
}

SD_PROMOTE_FUNC(sd_add, (... + (static_cast<promoted_type>(args))))
\```

## Consequences

### Advantages

* Improves code consistency and reduces the risk of type-related bugs.
* Simplifies the implementation of new arithmetic operations.
* Potentially improves performance by ensuring operations use the most appropriate type.
* Makes the codebase more extensible for future numeric types.

### Disadvantages

* Requires a significant refactoring effort across the mathematical operations in the codebase.
* May introduce temporary bugs during the transition if not done carefully.
* Could potentially impact compile times due to increased template usage.
* Might make some parts of the code more complex for developers unfamiliar with template metaprogramming.

### Risks

* Risk of introducing bugs during the refactoring process, especially in complex mathematical operations.
* Potential for decreased performance if the type promotion system is not carefully optimized.
* May cause confusion for developers who are more accustomed to explicit type casting.
* Could potentially break existing code that relies on specific type behaviors.

## Action Items

1. Develop a comprehensive guide for implementing and using the new type promotion system.
2. Create a set of unit tests to verify the correctness of type promotions for various type combinations.
3. Update the team's C++ style guide to include guidelines on using the new type promotion system.
4. Conduct a pilot implementation on a small, isolated part of the codebase (e.g., a single mathematical operation).
5. Schedule the refactoring process, prioritizing the most frequently used arithmetic operations.
6. Update all relevant documentation, including comments in the code and API documentation.
7. Implement benchmarks to compare performance before and after the changes.
8. Conduct thorough code reviews and testing for each refactored section.
9. Plan for a grace period to allow developers to familiarize themselves with the new system.
10. Monitor and address any issues or feedback arising from the new type promotion system.
11. Consider creating a static analysis tool to ensure consistent usage of the new type promotion system across the codebase.